# Scala-shell - описание

1. Основной класс - `CLI`. В своем цикле он считывает строчку от пользователя и прогоняет ее через конвеер `Preprocessor`, `Lexer`, `Parser`, `Interpreter`.
Он же хранит ссылу на `Context`.

2. `Preprocessor` занимается тем, что раскрывает все $-подстановки в строке, используя переданный ему `Context`. После препроцессинга мы *полностью* забываем про существование подстановок.

3. `Lexer` разбивает строку на токены (объекты класса `Token`). Он делает это *линейно*, т.е. без backtracking'а. Лексер **игнорирует** все пробелы.

4. `Parser` строит абстрактное синтаксическое дерево (класс `SyntaxTree`). Ему, в отличии от лексера, уже жизненно необходимо иногда возвращаться назад, поэтому он активно использует методы `ResettableStream.mark()` и `ResettableStream.reset()`

    - Про `Stream`ы. Это абстракция потока некоторых объектов в том смысле, что мы можем читать из него последовательно.
    Наследник `Stream` - `ResettableStream` позволяет отмечать (`mark()`) некоторые позиции в стриме, чтобы потом возвращаться к ним (`reset()`). Он поддерживает *рекурсивные метки*, т.е. корректно поддерживается, какая была последняя метка.
    **WARNING**. Пользователи должны сами следить за консистентностью меток, не оставляя в стриме неиспользованные. Пример неправильного использования:
    ```scala
    def foo(input: ResettableStream[Int]) {
        input.mark() // помечаем позицию №1
        bar(input)
        /* после вызова bar у нас в стриме лежат две метки:
           на позицию №1 и №2. Последняя - на №2, поэтому
           следующая строка откатит стрим на позицию №2
        */
        input.reset()
    }

    def bar(input: ResettableStream[Int]): Int {
      input.mark() // помечаем позицию №2
      // ошибка - метка оставлена в потоке!
      return input.read()
    }
    ```

    - Про `SyntaxTree`. Дерево - это просто обертка над `Node` + немного вспомогательных методов.

    - Про `Node`. Каждая нода хранит в себе список своих детей. Этот список *protected*, и наследники `Node` должны предоставлять отдельные публичные методы для доступа к своим детям (это и удобней, т.к. наследники могут дать этим методам более осмысленные имена, и вместо `AssignmentExpression.getChild(0)` мы будем писать `AssignmentExpression.variable`)

5. `Interpreter` - рекурсивно обходит AST, построенное парсером, выполняя логику по созданию и исполнению команд, пайпов и присваиваний.

    - Про команды. Команды создаются в фабрике `CommandsFactory` по имени. Фабрика проверяет, известна ли ей такая команда, и если да, то создает и возвращает инстанс какого-то наследника класса `Command`.
    Если имя неизвестно, то создается `ExternalCommand`, которая попытается выполнить незнакомую команду как внешнюю.

 Соответственно, для того, чтобы добавить команду, нужно:

    1. Создать наследника `Command`, внутри которого реализовать логику программы
    2. Добавить еще один случай в switch-case внутри фабрики, и там создать инстанс этой команды.
