# Patterns

1. `CLI` -- *Singleton*. Несмотря на общее убеждение в том,
  что чистые синглтоны -- чистое зло (с которым я, в целом, согласен), здесь
  его использование вполне оправдано. CLI действительно может быть лишь один на
  все приложение, да и сам язык требует от нас написать оборачивать точку входа
  в программу в `object`.

2. `interpretation.commands.Command` -- все наследники этого класса
  являют собой паттерн, как ни странно, *Command*.

  Действительно, для подавляющего большинства команд интерпретатор не знает и не желает
  знать, как выполняется та или иная команда (особенно учитывая то, что в перспективе
  количество таковых команд может дотигать феерических размеров). Кроме того,
  перенос логики исполнения команд в интерпретатор убил бы на месте модульность
  нашей системы -- любая правка в коде команды приводила бы к тому, что нужно
  перекомпилировать (и релизить) новую версию всего шелла.

  Вместо этого кто-то, кто знает, какую команду надо создавать, создаст и ее и сохранит
  под общим интерфейсом, и потом в другом месте кто-то другой просто исполнит ее, передав
  ей контекст исполнения.

  В данной реализации так получилось, что и создается, и исполняется команда в одном и том
  же месте, поэтому на полную мощь этот паттерн не используется, поскольку для такого проекта
  в этом необходимости не было.

3. `interpretation.commands.CommandsFactory` -- самая обычная *Factory*.
  Существование оправдано тем, что где-то в коде, так или иначе, придется написать логику
  отображения строковых названий команд в соответствующие классы. Фабрика агрегирует эту
  логику в себе, не позволяя ей расползаться по всему коду, что упрощает как добавление
  новых команд (достаточно добавить один случай в свитч), так и отладку (создание инстансов
  трейта `Command` -- это эксклюзивная прерогатива `CommandsFactory`)

4. `io.streams.{StdInStream, StdOutStream}` -- типичные адаптеры (*Adapter*), решающие
  типичную задачу в типичном юзкейзе -- есть некоторый пользовательский интерфейс (в нашем
  случае это `InputStream`, `OutputStream`), и есть библиотечный класс (у нас это `scala.io.StdIn`, `scala.ioStdOut`),
  и хочется их как-то подружить. Разумеется, менять код библиотечного класса мы не можем, поэтому
  используется обертка-адаптер.

5. `language.AST.Nodes.Node` -- можно смотреть на иерархию нодов как на пример
  *Composite pattern*. Несмотря на то, что в деталях имплементации есть несущественные различия
  (например, нет явно выделенного класса для `Leaf`), идейно решается такая же задача:
    - есть некоторая иерархия "часть-целое" (типы узлов синтаксическго дерева)
    - есть общий для всей этой иерархии интерфейс (`Node`)
    - есть некоторые общие (по сигнатуре) для всех элементов операции, детали
      реализации которых могут быть различны для каждого класса-наследника `Node`.

  Последний пункт в нашем проекте выражен не столь явно в силу использования паттерна `Visitor`,
  который отделяет все эти методы от нодов, но можно смотреть на это так,
  что если бы визитора не было бы, то у нод появились бы как раз общие по сигнатуре методы
  (`toString`, `compareTo`, etc.), которые для каждой ноды реализовывались бы по-разному -- как
  раз как в классическом *Composite*.

6. `language.AST.visitors.Visitor` -- какое AST без *Visitor*? Пример хрестматийный,
  но давайте в образовательных целях проговорми, зачем здесь *Visitor* и что он решает.

  *Visitor* позволяет отделить методы работы над деревом от самих классов-составляющих дерева.
  С одной стороны, это облегачет добавление новых методов в уже имеющуюся иерархию -- не нужно
  переписывать код `Node`. Кроме того, явным образом разносится логика различных несвязанных
  между собой операций -- pretty-printing лежит в одном *Visitor*, сравнение в другом и т.д.
  Наконец, это более безопасно в том смысле, что переопределяя новый *Visitor*, мы обязаны
  определить все виртуальные методы, что исключает возможность забыть определить метод на
  каком-нибудь классе (если вписывать в каждого наследника `Node` это руками, то такая ошибка
  становится намного более вероятной, а ловить ее порой не так уж и просто)

  В данной работе используется разновидность *Visitor* с generic return-type, что из личного
  опыта делает визиторов более гибкими и избавляет от приседаний с mutable-state внутри визитора
  (например, если очень хочется вернуть какой-нибудь результат обхода поддерева).

7. `language.LanguageService` -- *Facade*, инкапсулирующий в себе детали работы тулчейна
  парсинга и запуска программ.

  Это, с одной стороны, делает работу клиентов более удобной
  (например, если мы захотим помимо CLI придумать еще какой-нибудь GUI или еще что-нибудь такое,
  то нужно будет переписывать меньше строк кода). С другой стороны, это позволяет менять
  детали компиляции, не изменяя клиентский код (например, после еще пары добавочных усложнений может
  оказаться, что однопроходного парсинга больше не хватает, и надо делать два или вообще неопределенное
  количество проходов).
